<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Nightwatch.js]]></title><description><![CDATA[Nightwatch.js]]></description><link>http://85.17.207.188:2368/</link><generator>Ghost 0.5</generator><lastBuildDate>Fri, 06 Oct 2017 18:46:47 GMT</lastBuildDate><atom:link href="http://85.17.207.188:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Testing WebRTC Apps with Nightwatch]]></title><description><![CDATA[<h2 id="overviewofwebrtc">Overview of WebRTC</h2>

<p>WebRTC is a set of standards that enables realtime, peer to peer audio, video and data streaming between browser clients without any plug-ins. Its main uses today are audio/video conferencing, screen-sharing apps and multiplayer games but it can have other uses as well, like interacting with more tradidional SIP endpoints.</p>

<p>If you're new to WebRTC there are some great introductory articles at <a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">HTML5Rocks</a> and <a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Mozilla Developer Network</a>. WebRTC is now available in Chrome, Firefox and Opera and there are already plenty of apps and websites enabling users to communicate using this relatively new technology.</p>

<h2 id="gettingstarted">Getting started</h2>

<p>Automated testing of WebRTC applications can be cumbersome since it involves not only starting fake media devices but also starting more than one browser. A reliable test should check if at least two clients are connected and that they can interact with each other.</p>

<p>All that probably sounds like quite a bit of work but actually it's not that difficult to get it all working with Nightwatch. As a reference we'll use <a href="http://blog.andyet.com/2014/09/29/testing-webrtc-applications" target="_blank">the article</a> that Philipp Hancke at <a href="http://andyet.com/" target="_blank">andyet.com</a> has wrote for his blog. They run a quality web conferencing service at <a href="https://talky.io/" target="_blank">talky.io</a> and have a demo webrtc service at <a href="https://simplewebrtc.com/demo.html" target="_blank">simplewebrtc.com/demo.html</a> which we'll use in our test.</p>

<p>We'll start by creating a typical Nightwatch-enabled project and downloading all the needed binaries, like the selenium server and the chrome driver and installing Nigthwatch (with <code>npm install -g nightwatch</code>) if it's not already installed.</p>

<p>Then will create our <code>nightwatch.json</code> configuration file, which will look like this:  </p>

<pre class="language-javascript"><code class="language-javascript">  
{
  "src_folders" : ["./tests"],
  "output_folder" : "./reports",
  "live_output" : true,
  "parallel_process_delay" : 1500,

  "selenium" : {
    "start_process" : true,
    "server_path" : "./bin/selenium-server-standalone-2.43.1.jar",
    "log_path" : "",
    "cli_args" : {
      "webdriver.chrome.driver" : "bin/chromedriver"
    }
  },

  "test_settings" : {
    "default" : {
      "launch_url" : "<a href="https://simplewebrtc.com/demo.html">https://simplewebrtc.com/demo.html</a>",
      "silent" : true,
      "screenshots" : {
        "enabled" : false,
        "path" : "./screenshots"
      },
    },

    "chrome" : {
      "desiredCapabilities" : {
        "browserName" : "chrome",
        "chromeOptions" : {
          "args" : [
            "use-fake-device-for-media-stream", 
            "use-fake-ui-for-media-stream"
          ]
        }
      }
    }
  }
}</code></pre>

<p>For this prototype we'll be using chrome since it is easier to simulate a fake media device than Firefox. I have created two test environments, a <code>default</code> one and another named <code>chrome</code>.</p>

<h2 id="using-fake-media-device">Using fake media device</h2>

<p>Chrome provides two handy cli flags which we can use in our project to make things easier for testing: </p>

<ul><li><code>--use-fake-device-for-media-stream</code> - simulates a fake webcam and mic for testing</li><li><code>--use-fake-ui-for-media-stream</code> - allows skipping the security prompt for sharing the media device</li></ul>

<h2 id="test-overview">Test overview</h2>  
Next we'll proceed with writing the actual test. Currently the test project looks like this:  
<p></p>  

<pre><code>├── bin/
|   ├── selenium-server-standalone-2.43.1.jar
|   └── chromedriver
├── lib/  
|   └── custom-commands/
├── reports/
├── screenshots/  
├── tests/  
├── nightwatch.json
└── selenium-debug.log
</code></pre>



The test will do the following:  
<ul>  
<li>open two browsers in parallel and navigate to the given url - the second one will open with a slight delay</li>  
<li>wait a number of seconds to become connected</li>  
<li>check if both video streams are connected</li>  
<li>when the second client is closed, check if the remote video is removed from the page</li>  
</ul>

<h2 id="runningtestsinparallel">Running tests in parallel</h2>

<p>We'll make use of one of the relatively new features in Nightwatch and still in an experimental stage, the ability to run the tests in parallel.</p>

<p>If you're not familiar with this feature, the way it works is: say you have a few <em>environments</em> created in your nightwatch.json file under <code>test_settings</code>. You have a <code>default</code> environment, another one for <code>chrome</code> and another one for <code>firefox</code>. If you want to run the tests against both <code>chrome</code> and <code>firefox</code> environments in parallel, for instance, you simply specify both of them in the command line, like so:  </p>

<pre class="language-bash"><code class="language-bash">$ nightwatch --env chrome,firefox</code></pre>

<p></p>  

<p>The test runner will then start each of them in a separate <a href="http://nodejs.org/api/child_process.html" target="_blank"><code>child_process</code></a>. You can read a bit more about this in the <a href="http://local.nightwatchjs.org/guide#run-parallel">Developer Guide</a>.</p>

<h2 id="startingmorethanoneclient">Starting more than one client</h2>

<p>Now the fun part begins. To start a second client we need to use the above feature, i.e. running the test in parallel. But simply running the same test in two browsers in parallel is not enough. We'll do the testing only for the first client and the second one will just wait a few seconds and then exit. </p>

<p>To start two clients will just specify the <code>chrome</code> environment twice in the command line:  </p>

<pre class="language-bash"><code class="language-bash">$ nightwatch --env chrome,chrome</code></pre>

<p>We could also start a <code>firefox</code> environment but using a fake media device in Firefox is not very straightforward so we'll pass on that for now.</p>

<h2 id="adaptingtestsettingsatruntimeperenvironment">Adapting test settings at run-time per environment</h2>

<p>By default both clients will run the test the same way and output the results to <code>stdout</code> and write a JUnit XML report. Since the browser is the same the report file name will be the same as well and that means the second client's report will overwrite the first one. That's not very good because most of the testing will be done for the first client.</p>

<p>The way we fix this is by disabling the output at run-time for the second environment. And we'll do this in the <code>nightwatch.conf.js</code> configuration file, which looks a bit like this:  </p>

<pre><code class="language-javascript">module.exports = (function(settings) {
  if (process.env.__NIGHTWATCH_ENV_KEY !== 'chrome_1') {
    settings.output_folder = false;
    settings.output = false;
  }
  return settings;

})(require('./nightwatch.json'));</code></pre>

<p>The <code>nightwatch.conf.js</code> always takes precedence over <code>nightwatch.json</code> if both are present.</p>

<p>In the above we're reading the system environment variable <code>__NIGHTWATCH_ENV_KEY</code> which the Nightwatch runner populates with the current value of the testing environment that is being used - in this case <code>chrome</code> followed by a 1-based index: <code>chrome_1</code>. We want to disable the output for all other environments so we wont have any report file clashes.</p>

<p>We'll be using the same way of distinguishing between testing  environments in the actual test.</p>

<h2 id="writingtheactualtest">Writing the actual test</h2>

<p>It is important to be able to know inside the test which client (i.e. environment) it is the current one so that it  performs different actions. We'll be reading the same system variable as in the previous step: <code>__NIGHTWATCH_ENV_KEY</code>.</p>

<p>The test will do the following:  </p>

<ul style="list-style:decimal">  
<li>open up the given url and wait for body element to be visible</li>  
<li>first client only:  
<ul style="list-style:square">  
<li>wait for <code>#localVideo</code> element to become connected</li>  
<li>wait for remote video element to become connected</li>  
<li>after the remote video is connected, waits 1000ms</li>  
<li>wait for the remote video element to be removed - i.e. the other peer has left the room</li>  
</ul>  

<p><li>second client only - no assertions performed, only pauses for 10 seconds and then exits</li> <br>
</p></li> <br>
</ul><p></p>

<pre><code class="language-javascript">module.exports = new (function() {  
  var firstClient = process.env.__NIGHTWATCH_ENV_KEY == 'chrome_1';
  var testCases = this;

  testCases['opening the browser and navigating to the url'] = function (client) {
    client
      .url('https://simplewebrtc.com/demo.html?nightwatchjs')
      .waitForElementVisible('body', 1000);
  };

  if (firstClient) {
    testCases['wait for clients to become connected'] = function(client) {
      client
        .waitForElementVisible('#localVideo', 1500)
        .waitForClientConnected('#localVideo', 5000)
        .waitForClientConnected('#remotes .videoContainer:nth-child(1) video', 8000,
          'Remote video stream (%s) was connected in %s ms.');
    };

    testCases['wait for peer to disconnect'] = function (client) {
      client
        .pause(1000)
        .waitForElementNotPresent('#remotes video', 10000);
    };
  } else {
    testCases.suspend = function (client) {
      client.pause(10000);
    };
  }

  testCases.after = function(client) {
    client.end();
  };

})();
</code></pre>

<h2 id="checkingiftheclientsareconnected">Checking if the clients are connected</h2>

<p>You may have noticed in the above code snippet the presence of a custom command: <code>waitForClientConnected</code>. The way this works is it checks periodically for the <code>readyState</code> property of the supplied element to equal <code>4</code> (<code>HAVE_ENOUGH_DATA</code>). </p>

<p>The possible values of the <code>readyState</code> property are as follows:  </p>

<pre><code class="language-javascript">// ready state
const unsigned short HAVE_NOTHING = 0;  
const unsigned short HAVE_METADATA = 1;  
const unsigned short HAVE_CURRENT_DATA = 2;  
const unsigned short HAVE_FUTURE_DATA = 3;  
const unsigned short HAVE_ENOUGH_DATA = 4;  
readonly attribute unsigned short readyState;  
</code></pre>

<p>More information is available on the <a href="http://dev.w3.org/html5/pf-summary/video.html#media-element" target="_blank">W3C Video Element page</a>.</p>

<h2 id="resources">Resources</h2>

<p>That's about it. The test project is available on <a href="https://github.com/beatfactor/nightwatch-webrtcdemo">GitHub</a>.</p>

<p>Read more about WebRTC here:  </p>

<ul>  
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Introduction" target="_blank">developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Introduction</a>  
</li>  
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank">html5rocks.com/en/tutorials/webrtc/basics/</a></li>  
</ul>]]></description><link>http://85.17.207.188:2368/testing-webrtc-apps-with-nightwatch/</link><guid isPermaLink="false">0b003f18-bc97-41f4-aee5-610c1e762bfd</guid><dc:creator><![CDATA[Andrei Rusu]]></dc:creator><pubDate>Tue, 02 Dec 2014 23:49:40 GMT</pubDate></item></channel></rss>