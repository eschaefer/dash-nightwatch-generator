<!DOCTYPE html><html><!-- Mirrored from nightwatchjs.org/guide/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 06 Oct 2017 18:46:41 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->

      <title>Developer Guide | Nightwatch.js</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="In depth guides on how to use Nightwatch to write and execute tests.">
<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,200" rel="stylesheet" type="text/css">
<link rel="canonical" href="../index.html">
<meta charset="utf-8">
<meta property="og:title" content="Nightwatch.html">
<meta name="twitter:title" content="Nightwatch.html">
<meta name="twitter:description" content="In depth guides on how to use Nightwatch to write and execute tests.">
<meta name="twitter:image" content="../img/banner.png">

<meta property="og:image" content="../img/banner.png">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@nightwatchjs">
<meta name="twitter:creator" content="@nightwatchjs">
<meta name="google-site-verification" content="LGNZ66nvi-gru5DR_bV3jry2hqvlMoijhdWZkVT41ZM">

<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<link href="../css/main.css" rel="stylesheet">
<link href="../css/sidebar.css" rel="stylesheet">

<script>(function(p,h) {var q=p.split('../index.html');q.shift();q=q.map(function(a){return a.replace(/.+\.html$/,'$method')});h.setAttribute('data-uri',(p!='/'?'/'+q.join('../index.html'):p));if(p==='/cloud'){document.querySelector('meta[name="twitter:image"]').content='../img/cloud-banner.png';}})(location.pathname,document.documentElement);</script>
<noscript><style>#index-container {display: block}</style></noscript>
<link href="../css/themes/prism.css" rel="stylesheet">
  </head>
  <body><section id="guide-container" data-page-uri="/guide" class="secondary">
  <div class="jumbotron">
    <div class="container" style="height:130px">
      <div class="row">
        <div class="col-md-8">
          <h1>Developer Guide</h1>
        </div>
        <div class="col-md-4">
          <div class="carbonad"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="container bs-docs-container">
    <div class="row">
      <div class="col-md-3">
        <div class="bs-sidebar hidden-print" role="complementary" data-spy="affix" data-offset-top="60" data-offset-bottom="100">
          <ul class="nav bs-sidenav">

            <li>
              <a href="#using-nightwatch">Using Nightwatch</a>
              <ul class="nav">
                <li><a href="#writing-tests">Writing Tests</a></li>
                <li><a href="#using-xpath-selectors">Using Xpath</a></li>
                <li><a href="#bdd-expect-assertions">BDD Expect Assertions</a></li>
                <li><a href="#using-before-each-and-after-each-hooks">Test Hooks</a></li>
                <li><a href="#asynchronous-before-each-and-after-each-">Asynchronous Test Hooks</a></li>
                <li><a href="#external-globals">External Globals</a></li>
              </ul>
            </li>

            <li>
              <a href="#running-tests">Running Tests</a>
              <ul class="nav">
                <li><a href="#test-runner">Nightwatch Runner</a></li>
                <li><a href="#command-line-options">Command-line Options</a></li>
                <li><a href="#test-groups">Test Groups</a></li>
                <li><a href="#test-tags">Test Tags</a></li>
                <li><a href="#disabling-tests">Disabling Tests</a></li>
                <li><a href="#parallel-running">Parallel Running</a></li>
                <li><a href="#using-grunt">Using Grunt</a></li>
                <li><a href="#using-mocha">Using Mocha</a></li>
              </ul>
            </li>

            <li>
              <a href="#page-objects">Working with Page Objects</a>
              <ul class="nav">
                <li><a href="#using-page-objects">Using Page Objects</a></li>
                <li><a href="#defining-elements">Defining Elements</a></li>
                <li><a href="#defining-sections">Defining Sections</a></li>
                <li><a href="#writing-commands">Writing Commands</a></li>
              </ul>
            </li>

            <li>
              <a href="#extending">Extending Nightwatch</a>
              <ul class="nav">
                <li><a href="#writing-custom-commands">Custom commands</a></li>
                <li><a href="#writing-custom-assertions">Custom assertions</a></li>
                <li><a href="#custom-reporter">Custom reporter</a></li>
              </ul>
            </li>

            <li>
              <a href="#unit-testing">Unit Testing with Nightwatch</a>
              <ul class="nav">
                <li><a href="#writing-unit-tests">Writing Unit Tests</a></li>
                <li><a href="#asynchronous-unit-tests">Asynchronous Tests</a></li>
                <li><a href="#running-the-nightwatch-unit-tests">Running the Nightwatch unit tests</a></li>
                <li><a href="#using-a-combined-configuration">Using a Combined Configuration</a></li>
                <li><a href="#code-coverage">Code Coverage</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>

      <div class="col-md-9" role="main">
        <div class="docs-section">
          <div class="page-header">
            <h2 id="using-nightwatch">Using Nightwatch</h2>
          </div>

          <h3 id="writing-tests">Writing Tests</h3>
<p>Using the preferred CSS selector model to locate elements on a page, Nightwatch makes it very easy to write automated End-to-End tests.</p>
<p>Create a separate folder for tests in your project, e.g.: <code>tests</code>. Each file inside it will be loaded as a test by the Nightwatch test runner. A basic test will look like this:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'Demo test Google' : function (browser) {
    browser
      .url('<a href="http://www.google.com/">http://www.google.com</a>')
      .waitForElementVisible('body', 1000)
      .setValue('input[type=text]', 'nightwatch')
      .waitForElementVisible('button[name=btnG]', 1000)
      .click('button[name=btnG]')
      .pause(1000)
      .assert.containsText('#main', 'Night Watch')
      .end();
  }
};</code></pre>
</div>
<br>
<p class="alert alert-warning">
Remember <strong>always</strong> to call the <code>.end()</code> method when you want to close your test, in order for the Selenium session to be properly closed.
</p>

A test can have multiple steps, if needed:

<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'step one' : function (browser) {
    browser
      .url('<a href="http://www.google.com/">http://www.google.com</a>')
      .waitForElementVisible('body', 1000)
      .setValue('input[type=text]', 'nightwatch')
      .waitForElementVisible('button[name=btnG]', 1000)
  },

  'step two' : function (browser) {
    browser
      .click('button[name=btnG]')
      .pause(1000)
      .assert.containsText('#main', 'Night Watch')
      .end();
  }
};</code></pre></div>

<p>Tests can also be written in this format:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
this.demoTestGoogle = function (browser) {
  browser
    .url('<a href="http://www.google.com/">http://www.google.com</a>')
    .waitForElementVisible('body', 1000)
    .setValue('input[type=text]', 'nightwatch')
    .waitForElementVisible('button[name=btnG]', 1000)
    .click('button[name=btnG]')
    .pause(1000)
    .assert.containsText('#main', 'The Night Watch')
    .end();
};</code></pre>
</div>

          <h3 id="using-xpath-selectors">Using XPath selectors</h3>
<p>Nightwatch supports xpath selectors also. To switch to xpath instead of css selectors as the locate strategy, in your test call the method <code>useXpath()</code>, as seen in the example below. To switch back to CSS, call <code>useCss()</code>.</p>
<p>To always use xpath by default set the property <code>"use_xpath": true</code> in your test settings.</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
this.demoTestGoogle = function (browser) {
  browser
    .useXpath() // every selector now must be xpath
    .click("//tr[@data-recordid]/span[text()='Search Text']")
    .useCss() // we're back to CSS now
    .setValue('input[type=text]', 'nightwatch')
};</code></pre>
</div>
          <h3 id="bdd-expect-assertions">BDD Expect Assertions</h3>
<p>Nightwatch introduces starting with version <code>v0.7</code> a new BDD-style assertion library which greatly improves the flexibility as well as readability of the assertions.</p>
<p>The <code>expect</code> assertions use a subset of the <code>Expect</code> api from the <a href="http://chaijs.com/api/bdd/">Chai framework</a> and are available for elements only at this point. Here's an example:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'Demo test Google' : function (client) {
    client
      .url('<a href="http://google.no/">http://google.no</a>')
      .pause(1000);

    // expect element  to be present in 1000ms
    client.expect.element('body').to.be.present.before(1000);

    // expect element &lt;#lst-ib&gt; to have css property 'display'
    client.expect.element('#lst-ib').to.have.css('display');

    // expect element  to have attribute 'class' which contains text 'vasq'
    client.expect.element('body').to.have.attribute('class').which.contains('vasq');

    // expect element &lt;#lst-ib&gt; to be an input tag
    client.expect.element('#lst-ib').to.be.an('input');

    // expect element &lt;#lst-ib&gt; to be visible
    client.expect.element('#lst-ib').to.be.visible;

    client.end();
  }
};
</code></pre>
</div>

<p><br>
The <code>expect</code> interface provides a much more flexible and fluid language for defining assertions, significantly improved over the existing <code>assert</code> interface. The only downside is that it's not possible to chain assertions anymore and at this point custom messages aren't yet supported.</p>
<p><br>
For a complete list of available <code>expect</code> assertions, refer to the <a href="../api/index.html#expect">API docs</a>.</p>

          <h3 id="using-before-each-and-after-each-hooks">Using before[Each] and after[Each] hooks</h3>
<p>Nightwatch provides the standard <code>before</code>/<code>after</code> and <code>beforeEach</code>/<code>afterEach</code> hooks to be used in the tests.</p>
<p>The <code>before</code> and <code>after</code> will run before and after the execution of the test suite respectively, while <code>beforeEach</code> and <code>afterEach</code> are ran before and after each testcase (test step).</p>
<p>All methods have the Nightwatch instance passed as argument.</p>
<h4 id="example-">Example:</h4>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  before : function(browser) {
    console.log('Setting up...');
  },

  after : function(browser) {
    console.log('Closing down...');
  },

  beforeEach : function(browser) {

  },

  afterEach : function() {

  },

  'step one' : function (browser) {
    browser
     // ...
  },

  'step two' : function (browser) {
    browser
    // ...
      .end();
  }
};</code></pre>
</div>

<p>In the example above the sequence of method calls will be as follows: <code>before(), beforeEach(), "step one", afterEach(), beforeEach(), "step two", afterEach(), after()</code>.</p>
<p class="alert alert-warning">
For backwards compatibility reasons, the <code>afterEach</code> hook can receive the <code>browser</code> object only in its async form - <code>afterEach(browser, done) { .. }</code>
</p>
          <h3 id="asynchronous-before-each-and-after-each-">Asynchronous before[Each] and after[Each]</h3>
<p>All the <code>before[Each]</code> and <code>after[Each]</code> methods can also perform asynchronous operations, in which case they will require the <code>callback</code> passed as the second argument.</p>
<div class="alert alert-warning">
The <code>done</code> function <strong>must be called</strong> as the last step when the async operation completes. Not calling it will result in a timeout error.
</div>

<p></p><h4>Example with beforeEach &amp; afterEach:</h4><p></p>
<div class="sample-test">
<pre><code class="language-javascript">
module.exports = {
  beforeEach: function(browser, done) {
    // performing an async operation
    setTimeout(function() {
      // finished async duties
      done();
    }, 100);
  },

  afterEach: function(browser, done) {
    // performing an async operation
    setTimeout(function() {
      // finished async duties
      done();
    }, 200);
  }
};</code></pre>
</div>

<h4 id="controlling-the-done-invocation-timeout">Controlling the <code>done</code> invocation timeout</h4>
<p>By default the <code>done</code> invocation timeout is set to 10 seconds (2 seconds for unit tests). In some cases this might not be sufficient and to avoid a timeout error, you can increase this timeout by defining an <code>asyncHookTimeout</code> property (in milliseconds) in your external globals file (see below for details on external globals).</p>
<p>For an example, refer to the provided <a href="https://github.com/nightwatchjs/nightwatch/blob/master/examples/globalsModule.js#L20">globalsModule</a> example.</p>
<h4 id="explicitly-failing-the-test">Explicitly failing the test</h4>
<p>Failing the test intentionally in a test hook is achievable by simply calling <code>done</code> with an <code>Error</code> argument:</p>
<div class="sample-test">
<pre><code class="language-javascript">
module.exports = {
  afterEach: function(browser, done) {
    // performing an async operation
    performAsync(function(err) {
      if (err) {
        done(err);
      }
      // ...
    });
  }
};</code></pre>
</div>
          
          <h3 id="external-globals">External Globals</h3>
<p>Most of the time it's more useful to have your globals defined in an external file, specified in the <code>globals_path</code> property, instead of having them defined in <code>nightwatch.json</code>.</p>
<p>You can overwrite globals per environment as needed. Say you have your tests running locally and also against a remote staging server. Most of the times you will need some different setting up.</p>
<h4 id="global-hooks">Global Hooks</h4>
<p>The same set of hooks as per test suite is also available globally, outside the scope of the test. See the below example for more details.
In the case of global hooks, the <code>beforeEach</code> and <code>afterEach</code> refers to a test suite (i.e. test file), and are ran before and after a <em>test suite</em>.</p>
<h4 id="global-settings">Global Settings</h4>
<p>There are a number of globals which are holding test settings and can control test execution. These are detailed in the provided <a href="https://github.com/nightwatchjs/nightwatch/blob/master/examples/globalsModule.js">globalsModule</a> sample.</p>
<h4 id="example-">Example:</h4>
<div class="sample-test">
<pre><code class="language-javascript">
module.exports = {
  'default' : {
    isLocal : true,
  },

  'integration' : {
    isLocal : false
  },

  // External before hook is ran at the beginning of the tests run, before creating the Selenium session
  before: function(done) {
    // run this only for the local-env
    if (this.isLocal) {
      // start the local server
      App.startServer(function() {
        // server listening
        done();
      });
    } else {
      done();
    }
  },

  // External after hook is ran at the very end of the tests run, after closing the Selenium session
  after: function(done) {
    // run this only for the local-env
    if (this.isLocal) {
      // start the local server
      App.stopServer(function() {
        // shutting down
        done();
      });
    } else {
      done();
    }
  },

  // This will be run before each test suite is started
  beforeEach: function(browser, done) {
    // getting the session info
    browser.status(function(result) {
      console.log(result.value);
      done();
    });
  },

  // This will be run after each test suite is finished
  afterEach: function(browser, done) {
    console.log(browser.currentTest);
    done();
  }
};</code></pre>
</div>

        </div>

        <div class="docs-section">
          <div class="page-header">
            <h2 id="running-tests">Running Tests</h2>
          </div>

          <h3 id="test-runner">Test Runner</h3>
<p>Nightwatch includes a command-line test runner which makes it easy to run tests and generate useful output. There are a few different options on how to use the test runner, depending on your installation type.</p>
<h4 id="global">Global</h4>
<p>If you have installed Nightwatch globally (with <code>-g</code> option), the binary <code>nightwatch</code> will be available anywhere:</p>
<pre><code class="language-bash">$ nightwatch [source] [options]</code></pre>

<h4 id="project-specific">Project specific</h4>
<p>If you have Nightwatch installed as a dependency of your project, you can refer the binary from the <code>node_modules/.bin</code> folder:</p>
<p><br></p>
<h5 id="linux-and-macosx-">Linux and MacOSX:</h5>
<pre><code class="language-bash">$ ./node_modules/.bin/nightwatch [source] [options]</code></pre>

<p><br></p>
<h5 id="windows-">Windows:</h5>
<p>Create a file <code>nightwatch.js</code> and add the following line:</p>
<pre><code class="language-bash">require('nightwatch/bin/runner.js');</code></pre>

<p>Then run as follows:</p>
<pre><code class="language-bash">C:\workspace\project&gt; node nightwatch.js [source] [options]</code></pre>

<h4 id="tests-source">Tests source</h4>
<p>The optional <code>source</code> argument can be either one or more files or an entire folder. This can be located irrespectively of the <code>src_folders</code> setting.</p>
<p><br></p>
<h5 id="example-single-test-">Example - single test:</h5>
<pre><code class="language-bash">$ nightwatch tests/one/firstTest.js</code></pre>

<p><br></p>
<h5 id="example-2-individual-tests-">Example - 2 individual tests:</h5>
<pre><code class="language-bash">$ nightwatch tests/one/firstTest.js tests/secondTest.js</code></pre>

<p><br></p>
<h5 id="example-1-individual-test-and-1-folder-">Example - 1 individual test and 1 folder:</h5>
<pre><code class="language-bash">$ nightwatch tests/one/test.js tests/utils</code></pre>

          <h3 id="command-line-options">Command-line Options</h3>
<p>The test runner supports a number of run-time options to be passed to. To view all, run the following:</p>
<pre><code class="language-bash">$ nightwatch --help</code></pre>

<div class="table-responsive">
  <table class="table table-bordered table-striped">
    <thead>
     <tr>
       <th style="width: 100px;">Name</th>
       <th style="width: 100px;">Shortname</th>
       <th style="width: 50px;">default</th>
       <th>description</th>
     </tr>
    </thead>
    <tbody>
     <tr>
       <td><code>--config</code></td>
       <td><code>-c</code></td>
       <td><code>./nightwatch.json</code></td>
       <td>The location of the <code>nightwatch.json</code> file - the configuration file which the runner uses and which also includes the Selenium WebDriver options.</td>
     </tr>
     <tr>
       <td><code>--output</code></td>
       <td><code>-o</code></td>
       <td><code>tests_output</code></td>
       <td>The location where the JUnit XML reports will be saved.</td>
     </tr>
     <tr>
        <td><code>--reporter</code></td>
        <td><code>-r</code></td>
        <td><code>junit</code></td>
        <td>Name of a predefined reporter (e.g. junit) or path to a custom reporter file to use.</td>
     </tr>
     <tr>
       <td><code>--env</code></td>
       <td><code>-e</code></td>
       <td><code>default</code></td>
       <td>Which testing environment to use - defined in <code>nightwatch.json</code></td>
     </tr>
     <tr>
       <td><code>--verbose</code></td>
       <td><code></code></td>
       <td></td>
       <td>Shows extended selenium command logging during the session</td>
     </tr>
     <tr>
       <td><code>--version</code></td>
       <td><code>-v</code></td>
       <td></td>
       <td>Shows the version number</td>
     </tr>
     <tr>
       <td><code>--test</code></td>
       <td><code>-t</code></td>
       <td></td>
       <td>Runs only the specified test suite/module. By default the runner will attempt to run all tests in the <code>src_folders</code> settings folder(s) and their subfolders.</td>
     </tr>
     <tr>
       <td><code>--testcase</code></td>
       <td></td>
       <td></td>
       <td>Used only together with <code>--test</code>. Runs the specified testcase from the current suite/module.</td>
     </tr>
     <tr>
       <td><code>--group</code></td>
       <td><code>-g</code></td>
       <td></td>
       <td>Runs only the specified group of tests (subfolder). Tests are grouped by being placed in the same subfolder.</td>
     </tr>
     <tr>
       <td><code>--skipgroup</code></td>
       <td><code>-s</code></td>
       <td></td>
       <td>Skip one or several (comma separated) group of tests.</td>
     </tr>
     <tr>
       <td><code>--filter</code></td>
       <td><code>-f</code></td>
       <td></td>
       <td>Specify a filter (glob expression) as the file name format to use when loading the test files.</td>
     </tr>
     <tr>
       <td><code>--tag</code></td>
       <td><code>-a</code></td>
       <td></td>
       <td>Filter test modules by tags. Only tests that have the specified tags will be loaded.</td>
     </tr>
     <tr>
        <td><code>--skiptags</code></td>
        <td></td>
        <td></td>
        <td>Skips tests that have the specified tag or tags (comma separated).</td>
      </tr>
     <tr>
        <td><code>--retries</code></td>
        <td></td>
        <td></td>
        <td>Retries failed or errored testcases up to the specified number of times. Retrying a testcase will also retry the <code>beforeEach</code> and <code>afterEach</code> hooks, if any.</td>
      </tr>
      <tr>
       <td><code>--suiteRetries</code></td>
       <td></td>
       <td></td>
       <td>Retries failed or errored testsuites (test modules) up to the specified number of times. Retrying a testsuite will also retry the <code>before</code> and <code>after</code> hooks (in addition to the global beforeEach and afterEach respectively), if any are defined on the testsuite.</td>
     </tr>

    </tbody>
  </table>
</div>

          <h3 id="test-groups">Test Groups</h3>
<p>Nightwatch makes it possible to organize your test scripts into groups and run them as needed. To group tests together just place them in the same sub-folder. The folder name is the name of the group.</p>
<h4 id="example-">Example:</h4>
<pre>lib/
  ├── selenium-server-standalone.jar
custom-commands/
  ├── loginUser.js
  ├── attachPicture.js
tests/
  ├── logingroup
  |   ├── login_test.js
  |   └── otherlogin_test.js
  ├── addressbook
  |   ├── addressbook_test.js
  |   └── contact_test.js
  ├── chat
  |   ├── chatwindow_test.js
  |   ├── chatmessage_test.js
  |   └── otherchat_test.js
  └── smoketests
      ├── smoke_test.js
      └── othersmoke_test.js
</pre>

<p>To run only the <code>smoketests</code> group you would do the following:</p>
<pre><code class="language-bash">$ nightwatch --group smoketests</code></pre>

<p>Also, if you would want to skip running the <code>smoketests</code> group you would do the following:</p>
<pre><code class="language-bash">$ nightwatch --skipgroup smoketests</code></pre>

<p>To skip multiple groups, just add them as comma-separated:</p>
<pre><code class="language-bash">$ nightwatch --skipgroup addressbook,chat</code></pre>
          <h3 id="test-tags">Test Tags</h3>
<p>You can also selectively target tests to run based on tags, such that a test may be belong to multiple tags. For example, you might have a login test that belongs to a login suite as well as a sanity suite.</p>
<p>The tagging can be accomplished by adding the <code>@tags</code> property to a test module:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  '@tags': ['login', 'sanity'],
  'demo login test': function (client) {
     // test code
  }
};</code></pre>
</div>

<p>To select which tags to run, use the <code>--tag</code> command line flag:</p>
<pre><code class="language-bash">$ nightwatch --tag login</code></pre>

<p>Specify multiple tags as:</p>
<pre><code class="language-bash">$ nightwatch --tag login --tag something_else</code></pre>

<p><br>
To skip running tests with a specific tag, use the <code>--skiptags</code> flag:</p>
<pre><code class="language-bash">$ nightwatch --skiptags login</code></pre>

<p>Or to skip multiple tags, add each tag you want to skip as comma-separated:</p>
<pre><code class="language-bash">$ nightwatch --skiptags login,something_else</code></pre>

          <h3 id="disabling-tests">Disabling Tests</h3>
<p>To prevent a test module from running, simply set the <code>disabled</code> attribute in that module to <code>true</code>, like so:</p>
<pre><code class="language-javascript">
module.exports = {
  '@disabled': true, // This will prevent the test module from running.

  'sample test': function (client) {
    // test code
  }
};
</code></pre>

<p>This can be useful if you don't want to run certain tests that are known to be failing.</p>
<h4 id="disabling-individual-testcases">Disabling Individual Testcases</h4>
<p>Disabling individual testcases isn't currently supported out of the box. However it can be achieved relatively straightforward with a simple work-around. By simply converting the test method to a string, Nightwatch will ignore it.</p>
<p>Here's an example:</p>
<pre><code class="language-javascript">
module.exports = {
  'sample test': function (client) {
    // test code
  },

  // disabled
  'other sample test': ''+function (client) {
    // test code
  }
};
</code></pre>

          <h3 id="parallel-running">Parallel Running</h3>
<p>Starting with <code>v0.5</code> Nightwatch supports the tests to be run in parallel. This works by specifying multiple environments in the command line, separated by comma. E.g.:</p>
<pre><code class="language-bash">$ nightwatch -e default,chrome</code></pre>

<p>The above will run two environments named <code>default</code> and <code>chrome</code> in parallel.</p>
<h4 id="terminal-output">Terminal Output</h4>
<p>Each environment will be run as a separate <a href="http://nodejs.org/api/child_process.html"><code>child_process</code></a> and the output will be sent to the main process.</p>
<p>To make the output easier to read, Nightwatch by default buffers the output from each child process and displays everything at the end, grouped by environment.</p>
<div class="alert alert-warning">
  If you'd like to disable the output buffering and see the output from each child process as it is sent to stdout, simply set the property <code>"live_output" : true</code> on the top level in your <code>nightwatch.json</code> (e.g. after <code>selenium</code>).
</div>

<div class="alert alert-info">
  You can create a separate environment per browser (by chaining <code>desiredCapabilities</code>) and then run them in parallel. In addition, using the <code>filter</code> and <code>exclude</code> options tests can be split per environment in order to be ran in parallel.
</div>

<h4 id="via-workers">Via Workers</h4>
<p>Version <code>v0.7</code> introduces a new feature which allows the tests to be run in parallel. When this is enabled the test runner will launch a configurable number of child processes and then distribute the loaded tests over to be ran in parallel.</p>
<p>To enable test workers, set the <code>test_workers</code> top-level property, like so:</p>
<pre><code class="language-javascript">
"test_workers": {
  "enabled": true,
  "workers": "auto"
}   
</code></pre>

<p>or, simply:</p>
<p></p><pre><code class="language-javascript">
"test_workers": true
</code></pre>
<br>
The <code>workers</code> option configures how many child processes can run concurrently.<p></p>
<ul>
<li><code>"auto"</code> - determined by number of CPUs e.g. 4 CPUs means 4 workers</li>
<li><code>{number}</code> - specifies an exact number of workers</li>
</ul>
<p>Test concurrency is done at the file level. Each test file will fill a test worker slot. Individual tests/steps in a test file will not run concurrently.</p>
<div class="alert alert-warning">
Version 0.9 brings improved support for displaying output when running tests in parallel. We recommend setting <code>detailed_output</code> to <code>false</code> in your test settings for improved output readability.
</div>

          <h3 id="using-grunt">Using Grunt</h3>
<p><a href="http://gruntjs.com/" target="_blank">Grunt</a> is a popular JavaScript task runner. Starting with version <code>0.6</code> Nightwatch is bundled with 
an easy to use Grunt task which can be used in your existing Grunt-based build configuration for running the tests.</p>
<h4 id="usage">Usage</h4>
<p>First, load the Nightwatch grunt task at the top in your <code>Gruntfile.js</code>. </p>
<div class="sample-test">
<pre><code class="language-javascript">
module.exports = function(grunt) {
  var nightwatch = require('nightwatch');
  nightwatch.initGrunt(grunt);

  // ...

};
</code></pre>
</div>

<h4 id="task-configuration-and-targets">Task Configuration and Targets</h4>
<p>The Nightwatch task will have one or more targets which can be used in various ways, one way being to map them to environments. Available settings are:</p>
<ul>
<li><code>options</code> - the only available option so far is <code>cwd</code> - current working directory</li>
<li><code>argv</code> - command-line arguments that would normally be passed to the Nightwatch runner (e.g.: <code>env</code>);</li>
<li><code>settings</code> - the test settings specified to a single Nightwatch environment.</li>
</ul>
<h4 id="example">Example</h4>
<div class="sample-test">
<pre><code class="language-javascript">
grunt.initConfig({
  nightwatch: {
    options: {
      cwd: './'
    },

    'default' : {},

    browserstack: {
      argv: {
        env: 'browserstack'
      },
      settings: {
        silent: true
      }
    },

    'all' : {
      argv: {
        env: 'default,browserstack'
      }
    },
  }
});
</code></pre>
</div>

<p><br></p>
<p>Run the task as follows:</p>
<pre><code class="language-bash">$ grunt nightwatch:default</code></pre> 
or 

<pre><code class="language-bash">$ grunt nightwatch:browserstack</code></pre>

<p><br></p>
<p>There are also a few third-party Grunt plugins for Nightwatch which can be used instead, if you prefer. The most popular one is <a href="https://github.com/gextech/grunt-nightwatch" target="_blank">grunt-nightwatch</a>. </p>

          <h3 id="using-mocha">Using Mocha</h3>
<p>Starting with version <code>0.8</code> Nightwatch is bundled with a custom version of the popular Mocha test runner which allows running tests using Mocha, thus taking advantage of its interfaces and reporters.</p>
<h4 id="usage">Usage</h4>
<p>There are two main ways in which you can use Mocha with Nightwatch.</p>
<h4 id="from-nightwatch">From Nightwatch</h4>
<p>Mocha is used as an alternative test runner to the built-in one. This is done by specifying the <code>"test_runner"</code> option in the <code>nightwatch.json</code> configuration file.</p>
<p>Custom options can also be specified for Mocha:</p>
<div class="sample-test">
<pre><code class="language-javascript">
{
  ...
  "test_runner" : {
    "type" : "mocha",
    "options" : {
      "ui" : "bdd",
      "reporter" : "list"
    }
  }
  ...
}
</code></pre>
</div>

<p>or simply:</p>
<div class="sample-test">
<pre><code class="language-javascript">
{
  ...
  "test_runner" : "mocha"
  ...
}
</code></pre>
</div>

<p>A complete list of Mocha options that are supported can be found <a href="https://github.com/mochajs/mocha/wiki/Using-mocha-programmatically#set-options">here</a>.</p>
<p>The <code>test_runner</code> option can also be specified at test environment level:</p>
<div class="sample-test">
<pre><code class="language-javascript">
{
  "test_settings" : {
    "mocha_tests" : {
      "test_runner" : {
        "type" : "mocha",
        "options" : {
          "ui" : "tdd",
          "reporter" : "list"
        }
      }
    }
  }
  ...
}
</code></pre>
</div>

<h4 id="example">Example</h4>
<p>Writing a test in Mocha is the same as writing it in Nightwatch. Each testcase receives the <code>client</code> object, <code>hooks</code> also receiving a <code>done</code> callback for async operations.</p>
<div class="sample-test">
<pre><code class="language-javascript">
describe('Google demo test for Mocha', function() {

  describe('with Nightwatch', function() {

    before(function(client, done) {
      done();
    });

    after(function(client, done) {
      client.end(function() {
        done();
      });
    });

    afterEach(function(client, done) {
      done();
    });

    beforeEach(function(client, done) {
      done();
    });

    it('uses BDD to run the Google simple test', function(client) {
      client
        .url('<a href="http://google.com/">http://google.com</a>')
        .expect.element('body').to.be.present.before(1000);

      client.setValue('input[type=text]', ['nightwatch', client.Keys.ENTER])
        .pause(1000)
        .assert.containsText('#main', 'Night Watch');
    });
  });
});
</code></pre>
</div>

<p class="alert alert-warning">When using the mocha test runner from Nightwatch some cli options are not available, like <code>--retries</code>, <code>--suiteRetries</code>, <code>--reporter</code>.</p>

<h4 id="using-the-standard-mocha">Using the standard Mocha</h4>
<p>Running Nightwatch tests with the standard Mocha it's also possible, though a bit more boilerplate code is involved and you need to manage the selenium server.</p>
<h4 id="example">Example</h4>
<div class="sample-test">
<pre><code class="language-javascript">
var nightwatch = require('nightwatch');

describe('Github', function() {
  var client = nightwatch.initClient({
    silent : true
  });

  var browser = client.api();

  this.timeout(99999999);

  before(function() {

    browser.perform(function() {
      console.log('beforeAll')
    });

  });

  beforeEach(function(done) {
    browser.perform(function() {
      console.log('beforeEach')
    });

    client.start(done);
  });


  it('Demo test GitHub', function (done) {
    browser
      .url('<a href="https://github.com/nightwatchjs/nightwatch">https://github.com/nightwatchjs/nightwatch</a>')
      .waitForElementVisible('body', 5000)
      .assert.title('nightwatchjs/nightwatch · GitHub')
      .waitForElementVisible('body', 1000)
      .assert.visible('.container .breadcrumb a span')
      .assert.containsText('.container .breadcrumb a span', 'nightwatch', 'Checking project title is set to nightwatch');

    client.start(done);
  });

  afterEach(function() {
    browser.perform(function() {
      console.log('afterEach')
    });
  });

  after(function(done) {
    browser.end(function() {
      console.log('afterAll')
    });

    client.start(done);
  });

});

</code></pre>
</div>

        </div>

        <div class="docs-section">
          <div class="page-header">
            <h2 id="page-objects">Working with Page Objects</h2>
          </div>

          <h3 id="using-page-objects">Using Page Objects</h3>
<p>The Page Objects methodology is a popular pattern to write end-to-end tests by wrapping the pages or page fragments of a web app into objects.
The purpose of a page object is to allow a software client to do anything and see anything that a human can by abstracting away the underlying html actions needed to access and manipulate the page.</p>
<p>A comprehensive introduction to Page Objects can be found in <a href="http://martinfowler.com/bliki/PageObject.html" target="_blank">this article</a>.</p>
<div class="alert alert-info">
As of version <code>0.7</code> Nightwatch provides an enhanced and more powerful interface for creating page objects, significantly improved over the previous support. Page objects created prior to <code>v0.7</code> will still continue to work however we recommend upgrading to the new version.

To use the new version, your page object must contain either the <code>elements</code> or <code>sections</code> property. Otherwise, Nightwatch will defer to the old.
</div>


<h4 id="configuring-page-objects">Configuring Page Objects</h4>
<p>To create a page object simply create an object with properties that describe the page. Each page object should be located in a separate file, located in a designated folder. Nightwatch reads the page objects from the folder (or folders) specified in the <code>page_objects_path</code> configuration property.</p>
<p>The <code>page_objects_path</code> property can also be an array of folders, allowing you thus to logically split the page objects into smaller groups.</p>
<h4 id="the-url-property">The Url property</h4>
<p>You can optionally add a <code>url</code> property that designates the page's URL. To navigate to the page, you can call the <code>navigate</code> method on the page object.</p>
<p>The URL will usually be defined as a string:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  url: '<a href="http://google.com/">http://google.com</a>',
  elements: {}
};
</code></pre>
</div>

<p>It can also be a function in case the URL is dynamic. One use case for this is to support different test environments. You can create a function that gets called in the context of the page, thus allowing you to do:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  url: function() { 
    return this.api.launchUrl + '/login'; 
  },
  elements: {}
};
</code></pre>
</div>


          <h3 id="defining-elements">Defining Elements</h3>
<p>Most of the time, you will want to define elements on your page that your tests will interact with through commands and assertions. This is made simple using the <code>elements</code> property so that all your elements are defined in a single place. Especially in larger integration tests, using <code>elements</code> will go a long way to keep test code DRY.</p>
<p>Switching between css and xpath locate strategies is handled internally so you don't need to call <code>useXpath</code> and <code>useCss</code> in your tests. The default <code>locateStrategy</code> is css but you can also specify xpath:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  elements: {
    searchBar: { 
      selector: 'input[type=text]' 
    },
    submit: { 
      selector: '//[@name="q"]', 
      locateStrategy: 'xpath' 
    }
  }
};
</code></pre>
</div>

<p><br>
Or if you're creating elements with the same locate strategy as is default, you can use the shorthand:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  elements: {
    searchBar: 'input[type=text]'
  }
};
</code></pre>
</div>

<p><br>
Using the <code>elements</code> property allows you to refer to the element by its name with an <em>"@" prefix</em>, rather than selector, when calling element commands and assertions (<code>click</code>, etc).</p>
<p>Optionally, you can define an array of objects:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
var sharedElements = {
  mailLink: 'a[href*="mail.google.com"]'
};

module.exports = {
  elements: [
    sharedElements,
    { searchBar: 'input[type=text]' }
  ]
};
</code></pre>
</div>

<p><br>
Putting <code>elements</code> and <code>url</code> together, say you have the following defined above saved as a <code>google.js</code> file:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  url: '<a href="http://google.com/">http://google.com</a>',
  elements: {
    searchBar: { 
      selector: 'input[type=text]' 
    },
    submit: { 
      selector: '//[@name="q"]', 
      locateStrategy: 'xpath' 
    }
  }
};
</code></pre>
</div>

<p><br>
In your tests you will use it as follows:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'Test': function (client) {
    var google = client.page.google();

    google.navigate()
      .assert.title('Google')
      .assert.visible('@searchBar')
      .setValue('@searchBar', 'nightwatch')
      .click('@submit');

    client.end();
  }
};
</code></pre>
</div>
          <h3 id="defining-sections">Defining Sections</h3>
<p>Sometimes it is useful to define sections of a page. Sections do 2 things:</p>
<ul>
<li>Provide a level of namespacing under the page</li>
<li>Provide element-level nesting so that any element defined within a section is a descendant of its parent section in the DOM</li>
</ul>
<p>You can create sections using the <code>sections</code> property:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  sections: {
    menu: {
      selector: '#gb',
      elements: {
        mail: {
          selector: 'a[href<em>="mail"]'
        },
        images: {
          selector: 'a[href</em>="imghp"]'
        }
      }
    }
  }
};
</code></pre>
</div>

<p><br>
Your tests would use it as follows:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'Test': function (client) {
    var google = client.page.google();
    google.expect.section('@menu').to.be.visible;

    var menuSection = google.section.menu;
    menuSection.expect.element('@mail').to.be.visible;
    menuSection.expect.element('@images').to.be.visible;

    menuSection.click('@mail');

    client.end();
  }
};
</code></pre>
</div>

<p><br></p>
<div class="alert alert-info">
Note that every command and assertion on a section (other than <code>expect</code> assertions) returns that section for chaining. If desired, you can nest sections under other sections for complex DOM structures.
</div>

<h4 id="example-of-nesting-page-object-sections-">Example of nesting page object sections:</h4>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  sections: {
    menu: {
      selector: '#gb',
      elements: {
        mail: {
          selector: 'a[href<em>="mail"]'
        },
        images: {
          selector: 'a[href</em>="imghp"]'
        }
      },
      sections: {
        apps: {
          selector: 'div.gb_pc',
          elements: {
            myAccount: {
              selector: '#gb192'
            },
            googlePlus: {
              selector: '#gb119'
            }
          }
        }
      }
    }
  }
};
</code></pre>
</div>

<p><br>
Using a nested section in your test is straightforward:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'Test': function (client) {
    var google = client.page.google();
    google.expect.section('@menu').to.be.visible;

    var menuSection = google.section.menu;
    var appSection = menuSection.section.apps;
    menuSection.click('@appSection');

    appSection.expect.element('@myAccount').to.be.visible;
    appSection.expect.element('@googlePlus').to.be.visible;

    client.end();
  }
};
</code></pre>
</div>

          <h3 id="writing-commands">Writing Commands</h3>
<p>You can add commands to your page object using the <code>commands</code> property. This is a useful way to encapsulate logic about the page that would otherwise live in a test, or multiple tests.</p>
<p>Nightwatch will call the command on the context of the page or section. Client commands like <code>pause</code> are available via <code>this.api</code>. For chaining, each function should return the page object or section.</p>
<p>In this case, a command is used to encapsulate logic for clicking the submit button:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
var googleCommands = {
  submit: function() {
    this.api.pause(1000);
    return this.waitForElementVisible('@submitButton', 1000)
      .click('@submitButton')
      .waitForElementNotPresent('@submitButton');
  }
};

module.exports = {
  commands: [googleCommands],
  elements: {
    searchBar: {
      selector: 'input[type=text]'
    },
    submitButton: {
      selector: 'button[name=btnG]'
    }
  }
};
</code></pre>
</div>

<p><br>
Then the test is simply:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  'Test': function (client) {
    var google = client.page.google();
    google.setValue('@searchBar', 'nightwatch')
      .submit();

    client.end();
  }
};
</code></pre>
</div>

        </div>

        <div class="docs-section">
          <div class="page-header">
            <h2 id="extending">Extending Nightwatch</h2>
          </div>
          <h3 id="writing-custom-commands">Writing Custom Commands</h3>
<p>Most of the time you will need to extend the Nightwatch commands to suit your own application needs. Doing that is only a matter of creating a separate folder and defining your own commands inside there, each one inside its own file.</p>
<p>Then specify the path to that folder inside the <code>nightwatch.json</code> file, as the <code>custom_commands_path</code> property. The command name is the name of the file itself.</p>
<p>There are two main ways in which you can define a custom command:</p>
<h4 id="1-function-style-commands">1) Function-style commands</h4>
<p>This is the simplest form in which commands are defined, however they are also quite limited. Your command module needs to export a <code>command</code> function, which needs to call at least one Nightwatch api method (such as <code>.execute()</code>). This is due to a limitation of how the asynchronous queueing system of commands works. You can also wrap everything in a <code>.perform()</code> call. Client commands like <code>execute</code> and <code>perform</code> are available via <code>this</code>.</p>
<div class="sample-test" style="width: 600px">
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">
exports.command = function(file, callback) {
  var self = this;
  var imageData;
  var fs = require('fs');

  try {
    var originalData = fs.readFileSync(file);
    var base64Image = new Buffer(originalData, 'binary').toString('base64');
    imageData = 'data:image/jpeg;base64,' + base64Image;
  } catch (err) {
    console.log(err);
    throw "Unable to open file: " + file;
  }

  this.execute(
    function(data) { // execute application specific code
      App.resizePicture(data);
      return true;
    },

    [imageData], // arguments array to be passed

    function(result) {
      if (typeof callback === "function") {
        callback.call(self, result);
      }
    }
  );

  return this;
};
</code>
</pre>
</div>

<p>The example above defines a command (e.g. resizePicture.js) which loads an image file as <code>data-URI</code> and calls a method named <code>resizePicture</code> (via <code>.execute()</code>), defined inside the application.</p>
<p>With this command, the test will look something like:</p>
<div class="sample-test" style="width: 600px">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  "testing resize picture" : function (browser) {
    browser
      .url("<a href="http://app.host/">http://app.host</a>")
      .waitForElementVisible("body")
      .resizePicture("/var/www/pics/moon.jpg")
      .assert.element(".container .picture-large")
      .end();
  }
};</code></pre>
</div>

<h4 id="2-class-style-commands">2) Class-style commands</h4>
<p>This is how most of the Nightwatch's own commands are written. Your command module needs to export a class constructor with a <code>command</code> instance method representing the command function. Commands written like this should inherit from <code>EventEmitter</code> and manually signal the <code>complete</code> event, to indicate command completion.</p>
<p>Class-based <code>command</code> methods are run in the context (the value of <code>this</code>) of the class instance. The test <code>api</code> object is available as <code>this.api</code> or <code>this.client.api</code>, where <code>this.client</code> is the Nightwatch instance itself.</p>
<p>The example below is the <code>.pause()</code> command:</p>
<div class="sample-test" style="width: 600px">
<pre data-language="javascript"><code class="language-javascript">
var util = require('util');
var events = require('events');

function Pause() {
  events.EventEmitter.call(this);
}

util.inherits(Pause, events.EventEmitter);

Pause.prototype.command = function(ms, cb) {
  var self = this;
  // If we don't pass the milliseconds, the client will
  // be suspended indefinitely
  if (!ms) {
    return this;
  }
  setTimeout(function() {
    // if we have a callback, call it right before the complete event
    if (cb) {
      cb.call(self.client.api);
    }

    self.emit('complete');
  }, ms);

  return this;
};

module.exports = Pause;</code></pre>
</div>

<p><br></p>
<h5 id="the-complete-event">The "complete" event</h5>
<p>Signaling the <code>complete</code> event needs to be done inside an asynchronous action (e.g. a <code>setTimeout</code> call). Command classes that do not extend <code>EventEmitter</code> will be treated similar to command functions, requiring that the <code>command</code> method calls at least one Nightwatch api method to be able to complete.</p>
<p class="alert alert-warning">Using ES6 classes as custom commands is not supported at the moment. See <a href="https://github.com/nightwatchjs/nightwatch/issues/1199">nightwatchjs#1199</a> for more details.</p>

          <h3 id="writing-custom-assertions">Writing Custom Assertions</h3>
<p>Nightwatch allows you to even define your own assertions, extending the available <code>.assert</code> and <code>.verify</code> namespaces.</p>
<p>Assertions implement a simple interface which is shared between built-in assertions and custom ones:</p>
<div class="sample-test" style="width: 500px">

<pre data-language="javascript"><code class="language-javascript">
exports.assertion = function() {

  /**
   * The message which will be used in the test output and
   * inside the XML reports
   * @type {string}
   */
  this.message;

  /**
   * A value to perform the assertion on. If a function is
   * defined, its result will be used.
   * @type {function|*}
   */
  this.expected;

  /**
   * The method which performs the actual assertion. It is
   * called with the result of the value method as the argument.
   * @type {function}
   */
  this.pass = function(value) {

  };

  /**
   * The method which returns the value to be used on the
   * assertion. It is called with the result of the command's
   * callback as argument.
   * @type {function}
   */
  this.value = function(result) {

  };

  /**
   * Performs a protocol command/action and its result is
   * passed to the value method via the callback argument.
   * @type {function}
   */
  this.command = function(callback) {

    return this;
  };

};</code></pre>

</div>

<p class="alert alert-info">Custom assertions also inherit from <a href="http://nodejs.org/api/events.html" target="_blank">EventEmitter</a>. To see some examples, check the assertions module on Github:<br><a href="https://github.com/beatfactor/nightwatch/tree/master/lib/api/assertions" target="_blank">/nightwatch/tree/master/lib/selenium/assertions</a></p>

          <h3 id="custom-reporter">Custom Reporter</h3>
<p>If you'd like to define your own reporter in addition to the built-in ones (stdout and junit-xml) you can do so in two ways:</p>
<h4 id="the-reporter-command-line-argument">The <code>--reporter</code> command-line argument</h4>
<h5 id="interface-">Interface:</h5>
<div class="sample-test">
<pre><code class="language-javascript">
module.exports = {
  write : function(results, options, done) {
    done();
  }
};</code></pre>
</div>

<h4 id="the-reporter-method-in-your-external-globals-file-">The <code>reporter</code> method in your external <code>globals</code> file.</h4>
<p>See the provided <a href="https://github.com/beatfactor/nightwatch/blob/master/examples/globalsModule.js">globalsModule.js</a> for an example.</p>
<h4 id="example-">Example:</h4>
<div class="sample-test">
<pre><code class="language-javascript">
module.exports = {
  reporter : function(results, done) {
    console.log(results);
    done();
  }
};</code></pre>
</div>

        </div>

        <div class="docs-section">
          <div class="page-header">
            <h2 id="unit-testing">Unit Testing with Nightwatch</h2>
          </div>

          <h3 id="writing-unit-tests">Writing Unit Tests</h3>
<p>Unit testing in Nightwatch has been refined in version <code>0.9</code>. Unit tests now written in Nightwatch are also fully compatible with <a href="https://mochajs.org/#exports">Mocha's Exports</a> interface, so you can use either test runners. In fact, all Nightwatch's unit tests have been rewritten so they can be ran with either Nightwatch or Mocha.</p>
<div class="alert alert-info">
For backwards compatibility reasons, to take advantage of the improved unit testing support you need to set the toggle setting <code>compatible_testcase_support</code> to <code>true</code> in your test settings.
</div>

<p>Unit tests written in versions prior to <code>0.9</code> will still continue to work however we recommend upgrading them.</p>
<h4 id="disabling-automatic-selenium-session">Disabling automatic selenium session</h4>
<p>Nightwatch automatically attempts to connect to the specified selenium server and create a session.
When running unit tests this needs to be disabled by setting the <code>start_session</code> property to <code>false</code> inside the <code>selenium</code> settings group either on the root level or inside a specific environment.</p>
<h4 id="assertion-framework">Assertion framework</h4>
<p>Starting with <code>0.9</code>, in the improved support for unit tests, the <code>client</code> object is no longer passed as an argument to the test. The only argument passed now is the <code>done</code> callback to be used for asynchronous tests.</p>
<p>You can use whatever assertion framework you like. <a href="http://chaijs.com/">Chai.js</a> is quite a good one and very flexible. We use the internal Node.js <code>assert</code> module in the Nightwatch unit tests.</p>
<p>You can still refer the <code>client</code> object via <code>this.client</code> in your tests.</p>
<h4 id="example">Example</h4>
<p>Here's a subset of the unit test for the <code>utils.js</code> Nightwatch module:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
var assert = require('assert');
var common = require('../../common.js');
var Utils = common.require('util/utils.js');

module.exports = {
  'test Utils' : {
    testFormatElapsedTime : function() {

      var resultMs = Utils.formatElapsedTime(999);
      assert.equal(resultMs, '999ms');

      var resultSec = Utils.formatElapsedTime(1999);
      assert.equal(resultSec, '1.999s');

      var resultMin = Utils.formatElapsedTime(122299, true);
      assert.equal(resultMin, '2m 2s / 122299ms');
    },

    testMakeFnAsync : function() {
      function asyncFn(cb) {
        cb();
      }

      function syncFn() {}

      var convertedFn = Utils.makeFnAsync(1, syncFn);
      var called = false;
      convertedFn(function() {
        called = true;
      });

      assert.equal(Utils.makeFnAsync(1, asyncFn), asyncFn);
      assert.ok(called);
    }
  }
};

</code></pre>
</div>

          <h3 id="asynchronous-unit-tests">Asynchronous Unit Tests</h3>
<p>The argument to the test function is the optional <code>done</code> callback which signals the test is complete.
If present, the callback must be called when the async operation finishes.</p>
<h4 id="example">Example</h4>
<p>Here's unit test which checks if Nightwatch throws an error if you don't invoke the <code>done</code> callback within a set time (10 ms).</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
module.exports = {
  var path = require('path');
  var assert = require('assert');
  var common = require('../../common.js');
  var CommandGlobals = require('../../lib/globals/commands.js');
  var Runner = common.require('runner/run.js');

  module.exports = {
    'testRunner': {
      before: function (done) {
        CommandGlobals.beforeEach.call(this, done);
      },

      after: function (done) {
        CommandGlobals.afterEach.call(this, done);
      },

      beforeEach: function () {
        process.removeAllListeners('exit');
        process.removeAllListeners('uncaughtException');
      },

      'test async unit test with timeout error': function (done) {
        var testsPath = path.join(__dirname, '../../asynchookstests/unittest-async-timeout.js');
        var globals = {
          calls : 0,
          asyncHookTimeout: 10
        };

        process.on('uncaughtException', function (err) {
          assert.ok(err instanceof Error);
          assert.equal(err.message, 'done() callback timeout of 10 ms was reached while executing "demoTest". ' +
            'Make sure to call the done() callback when the operation finishes.');

          done();
        });

        var runner = new Runner([testsPath], {
          seleniumPort: 10195,
          silent: true,
          output: false,
          persist_globals : true,
          globals: globals,
          compatible_testcase_support : true
        }, {
          output_folder : false,
          start_session : false
        });

        runner.run().catch(function(err) {
          done(err);
        });
      }
    }
  };
};
</code></pre>
</div>

<p>The complete test suite can be viewed on GitHub:
<a href="https://github.com/nightwatchjs/nightwatch/tree/master/test/src/runner/testRunner.js">https://github.com/nightwatchjs/nightwatch/tree/master/test/src/runner/testRunner.js</a></p>

          <h3 id="running-the-nightwatch-unit-tests">Running the Nightwatch unit tests</h3>
<p>To get an idea of how running unit tests with Nightwatch works you can head over to our <a href="https://github.com/nightwatchjs/nightwatch">GitHub page</a>, clone the project and follow the instructions on how to run the tests.</p>
<p>You can also check out Nightwatch's own complete test suite for examples:
<a href="https://github.com/nightwatchjs/nightwatch/tree/master/test/src">https://github.com/nightwatchjs/nightwatch/tree/master/test/src</a></p>
<p>Here's the configuration needed to run them:</p>
<div class="sample-test">
<pre data-language="javascript"><code class="language-javascript">
{
  "src_folders" : ["./test/src"],
  "selenium" : {
    "start_process" : false,
    "start_session" : false
  },

  "test_settings" : {
    "default" : {
      "filter" : "<em>*/</em>.js",
      "compatible_testcase_support" : true
    }
  }
}
</code></pre>
</div>

          <h3 id="using-a-combined-configuration">Using a Combined Configuration</h3>
<p>Below it's an example of how you can combine end-to-end tests and unit tests in the same <code>nightwatch.json</code> configuration file.
Notice the usage of <code>exclude</code> and <code>filter</code> properties.</p>
<p>An empty <code>exclude</code> means we want to reset its value and rely only on <code>filter</code>.</p>
<pre><code class="language-javascript">{
  <strong>"src_folders"</strong> : ["./examples/tests", "./examples/unittests"],
  <strong>"output_folder"</strong> : "./examples/reports",

  <strong>"selenium"</strong> : {
    "start_process" : true,
    "server_path" : "./bin/selenium-server-standalone.jar",
    "log_path" : "",
    "host" : "127.0.0.1",
    "port" : 4444,
    "cli_args" : {
      "webdriver.chrome.driver" : "",
      "webdriver.ie.driver" : ""
    }
  },

  <strong>"test_settings"</strong> : {
    "default" : {
      "launch_url" : "http://localhost",
      "selenium_port"  : 4444,
      "selenium_host"  : "localhost",
      "silent": true,
      "screenshots" : {
        "enabled" : false,
        "path" : ""
      },
      "desiredCapabilities": {
        "browserName": "firefox",
        "javascriptEnabled": true,
        "acceptSslCerts": true
      },
      "exclude" : "./examples/unittests/*"
    },

    "unittests" : {
      "selenium" : {
        "start_process" : false,
        "start_session" : false
      },
      "filter" : "./examples/unittests/*",
      "exclude" : ""
    }
  }
}</code></pre>
          <h3 id="code-coverage">Code Coverage</h3>
<p>At the moment, Nightwatch doesn't provide a coverage reporter but it is something that's being planned for a future release.
In the meantime you can write a custom reporter which will output coverage data. See the <a href="http://local.nightwatchjs.org/guide#custom-reporter">custom reporter</a> section for details and the <a href="http://mochajs.org/#htmlcov">Mocha HTMLCov</a> reporter for how the reporter should look like.</p>
<h4 id="3rd-party-coverage-service">3rd party coverage service</h4>
<p>There are some hosted services which provide the reporting and metrics for you in a modern web interface. These services will typically require coverage data in LCOV format. Nightwatch uses <a href="https://coveralls.io/github/nightwatchjs/nightwatch?branch=master">coveralls.io</a>.</p>
<p>For details on how an LCOV reporter should look like and how to integrate with your project, you can check out the <a href="https://www.npmjs.com/package/mocha-lcov-reporter">mocha-lcov-reporter</a>.</p>

        </div>
      </div>
    </div>
  </div>
  <br><br>
</section></body><!-- Mirrored from nightwatchjs.org/guide/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 06 Oct 2017 18:46:42 GMT --></html>